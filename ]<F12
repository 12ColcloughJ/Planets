use raylib::{Color, Vector2, RaylibHandle, consts};

mod planet;
use planet::{Planet, PLANET_DENSITY};

const G: f32 = 0.1;

struct App {
	rl: RaylibHandle,
	planets: Vec<Planet>,
}

impl App {
	pub fn new(ray: RaylibHandle) -> App {
		App {
			rl: ray,
			planets: vec![],
		}
	}

	pub fn main_loop(&mut self) {
		while !self.rl.window_should_close() {
			let dt = self.rl.get_frame_time();
			self.update(dt);

			self.rl.begin_drawing();
			self.rl.clear_background(Color::BLACK);

			self.draw();

			self.rl.draw_fps(10, 10);
			self.rl.end_drawing();
		}
	}
	
	pub fn update(&mut self, dt: f32) {
		self.kill_dead_planets();

		for i in 0..self.planets.len() {   // For each planet
			for mut j in i..self.planets.len() {  // For every other planet
				if i != j {
					let (df1, df2) = self.get_grav_force_between_two_planets(i, j);
					self.planets[i].res_force += df1;
					self.planets[j].res_force += df2;

					if self.check_for_collision(&self.planets[i], &self.planets[j]) {
						self.collide(i, j);
						self.kill_dead_planets();
						j -= 1;
					}
				}
			}

			self.planets[i].update(dt);
		}
	}

	pub fn draw(&self) {
		for p in self.planets.iter() {
			p.draw(&self.rl);
		}
	}

	fn kill_dead_planets(&mut self) {
		self.planets.retain(|i|!i.has_merged);
	}

	fn check_for_collision(&self, p1: &Planet, p2: &Planet) -> bool {
		(p2.pos - p1.pos).length() <= p1.radius + p2.radius
	}

	fn collide(&mut self, p1: usize, p2: usize) {
		let total_momentum = self.planets[p1].get_momentum() + self.planets[p2].get_momentum();

		let p1_volume = self.planets[p1].mass/PLANET_DENSITY;
		let p2_volume = self.planets[p2].mass/PLANET_DENSITY;

		let new_rad = (((3.0/4.0) * (p1_volume + p2_volume))/consts::PI as f32).powf(1.0/3.0);
		let total_mass = self.planets[p1].mass + self.planets[p2].mass;

		self.planets[p1].has_merged = true;
		self.planets[p2].has_merged = true;

		self.planets.push(Planet::new(
			if self.planets[p1].radius > self.planets[p2].radius {
				self.planets[p1].pos
			} else {
				self.planets[p2].pos
			},
			total_momentum/total_mass,
			new_rad,
			total_mass,
		));
	}

	fn get_grav_force_between_two_planets(&self, i1: usize, i2: usize) -> (Vector2, Vector2) {   // returns force on pl1 and pl2
		let pos = self.planets[i2].pos - self.planets[i1].pos;
		let angle = self.planets[i1].pos.angle_to(self.planets[i2].pos);
		let angle2 = angle + consts::PI as f32;
		let f_mag = (G * self.planets[i1].mass * self.planets[i2].mass)/(pos.length().powi(2));
		
		(Vector2 { x: f_mag * angle.cos(), y: f_mag * angle.sin() }, Vector2 { x: f_mag * angle2.cos(), y: f_mag * angle2.sin() })
	}

	pub fn add_planet(&mut self, pos: Vector2, vel: Vector2, rad: f32) {
		self.planets.push( planet::Planet::new(pos, vel, rad, 0.0) );
	}

	pub fn make_square(&mut self, pos: Vector2, rad: f32, sep: f32, w: u32, h: u32) {
		for i in 0..w {
			for j in 0..h {
				self.planets.push(Planet::new(
					Vector2 { x: i as f32 * (rad + sep) * 2.0, y: j as f32 * (rad + sep) * 2.0 } + pos,
					Vector2::zero(),
					rad,
					0.0
				));
			}
		}
	}
}

fn main() {
	let rl = raylib::init()
		.size(1000, 800)
		.title("N-body")
		.build();

	rl.set_target_fps(144);

	let mut a = App::new(rl);
	/*
	a.add_planet(Vector2 { x: 300.0, y: 310.0 }, Vector2 { x: 10.0, y: 10.0 }, 5.0);
	a.add_planet(Vector2 { x: 500.0, y: 300.0 }, Vector2::zero(), 5.0);
	a.add_planet(Vector2 { x: 700.0, y: 300.0 }, Vector2::zero(), 5.0);
	a.add_planet(Vector2 { x: 400.0, y: 700.0 }, Vector2::zero(), 5.0);
	a.add_planet(Vector2 { x: 400.0, y: 500.0 }, Vector2::zero(), 5.0);
	*/

	a.make_square(Vector2{ x: 500.0, y: 500.0 }, 10.0, 100.0, 2, 2);

	a.main_loop();
}
